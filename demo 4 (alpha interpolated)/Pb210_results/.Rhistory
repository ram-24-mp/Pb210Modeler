# Define the path to your Excel file
print("select mass data")
file_path=file.choose()
new_column_names_mass_data <- c("X", "X.1")
mass_data <- read_excel(file_path, col_names = TRUE, col_types = "numeric")
library("readxl")
# Specify the new column names
new_column_names_mass_data <- c("X", "X.1")
mass_data <- read_excel(file_path, col_names = TRUE, col_types = "numeric")
mass_data=as.data.frame(mass_data)
colnames(mass_data)=new_column_names_mass_data
mass_data
# Perform linear interpolation on the X values
mass_data$interpolated_X <- na.approx(mass_data$X, na.rm = FALSE)
library("zoo")
# Perform linear interpolation on the X values
mass_data$interpolated_X <- na.approx(mass_data$X, na.rm = FALSE)
# Initialize a vector for propagated uncertainties
mass_data$propagated_uncertainties <- NA
mass_data
# Loop through the interpolated X to calculate uncertainties
for (i in 1:nrow(mass_data)) {
# Only calculate propagated uncertainty if the current uncertainty is NA
if (is.na(mass_data$X.1[i])) {
# Find the nearest known X on both sides
left_index <- i - 1
while (left_index > 0 && (is.na(mass_data$X[left_index]) || is.na(mass_data$X.1[left_index]))) {
left_index <- left_index - 1
}
right_index <- i + 1
while (right_index < nrow(mass_data) && (is.na(mass_data$X[right_index]) || is.na(mass_data$X.1[right_index]))) {
right_index <- right_index + 1
}
# Check if we found valid indices
if (left_index > 0 && right_index < nrow(mass_data)) {
delta_y1 <- mass_data$X.1[left_index]  # Use the correct column for uncertainties
x1 <- left_index
delta_y2 <- mass_data$X.1[right_index]  # Use the correct column for uncertainties
x2 <- right_index
partial_x=(i-x1)/(x2-x1)
# Calculate propagated uncertainty
propagated_uncertainty <- sqrt((delta_y1)^2 + (partial_x * delta_y2)^2)
mass_data$propagated_uncertainties[i] <- propagated_uncertainty
}
}
}
mass_data
mass_data[,1]=mass_data[,3]
mass_data$X.1[is.na(mass_data$X.1)] <- mass_data$propagated_uncertainties[is.na(mass_data$X.1)]
mass_data=mass_data[,1:2]
mass_data
library("zoo")
library("readxl")
file_path=file.choose()
# Specify the new column names
new_column_names_mass_data <- c("X", "X.1")
# Read the Excel file
mass_data <- read_excel(file_path, col_names = TRUE, col_types = "numeric")
mass_data=as.data.frame(mass_data)
colnames(mass_data)=new_column_names_mass_data
# Perform linear interpolation on the X values
mass_data$interpolated_X <- na.approx(mass_data$X, na.rm = FALSE)
# Initialize a vector for propagated uncertainties
mass_data$propagated_uncertainties <- NA
# Loop through the interpolated X to calculate uncertainties
for (i in 1:nrow(mass_data)) {
# Only calculate propagated uncertainty if the current uncertainty is NA
if (is.na(mass_data$X.1[i])) {
# Find the nearest known X on both sides
left_index <- i - 1
while (left_index > 0 && (is.na(mass_data$X[left_index]) || is.na(mass_data$X.1[left_index]))) {
left_index <- left_index - 1
}
right_index <- i + 1
while (right_index < nrow(mass_data) && (is.na(mass_data$X[right_index]) || is.na(mass_data$X.1[right_index]))) {
right_index <- right_index + 1
}
# Check if we found valid indices
if (left_index > 0 && right_index < nrow(mass_data)) {
delta_y1 <- mass_data$X.1[left_index]  # Use the correct column for uncertainties
x1 <- left_index
delta_y2 <- mass_data$X.1[right_index]  # Use the correct column for uncertainties
x2 <- right_index
partial_der=(i-x1)/(x2-x1)
# Calculate propagated uncertainty
propagated_uncertainty <- sqrt(((1-partial_der)*delta_y1)^2 + (partial_der * delta_y2)^2)
mass_data$propagated_uncertainties[i] <- propagated_uncertainty
}
}
}
mass_data
library(zoo)
library(readxl)
# Define the path to your Excel file
new_column_names_pb210_data <- c("X", "X.1", "X.2", "X.3")
# Read the Excel file
file_path2=file.choose()
pb210_data <- read_excel(file_path2, col_names = TRUE, col_types = "numeric")
if (ncol(pb210_data)==2){
new_column_names_pb210_data=new_column_names_pb210_data[1:2]
}
colnames(pb210_data) <- new_column_names_pb210_data
pb210_data=as.data.frame(pb210_data)
# Bn=A*(C/A)^(n/N) exponential interpolation of activities
pb210_data
# Bn=A*(C/A)^(n/N) exponential interpolation of activities
for (i in 1:nrow(pb210_data)) {
# Check if the current uncertainty is missing
if (is.na(pb210_data[i, 2])) {
# Get the first activity from the previous row
first_activity_tot=pb210_data[(i-1),1]
first_uncer_tot=pb210_data[(i-1),2]
# Initialize a variable to track the end of the missing data
j = i
# Loop to fill in missing uncertainties
length_missing_data=1
while (j <= nrow(pb210_data) && is.na(pb210_data[j, 2])) {
j = j + 1
length_missing_data=length_missing_data+1
}
length_missing_data=length_missing_data-1
segments=length_missing_data+1
filler_vec=vector("numeric", length_missing_data)
filler_vec_uncer=vector("numeric", length_missing_data)
if (ncol(pb210_data)==4){
filler_vec2=vector("numeric", length_missing_data)
filler_vec_uncer2=vector("numeric", length_missing_data)
}
# Now j is the first non-missing uncertainty after the missing values
if (j <= nrow(pb210_data)) {
second_activity_tot = pb210_data[j, 1]
second_uncer_tot = pb210_data[j, 2]
# Check if both activities are numeric
if (is.numeric(first_activity_tot) && is.numeric(second_activity_tot)) {
# Calculate the filled activity
for (k in 1:length_missing_data){
filler_vec[k]=first_activity_tot*(second_activity_tot/first_activity_tot)^(k/segments)
filler_vec_uncer[k]=filler_vec[k]*sqrt(((second_activity_tot/first_activity_tot)^(k/segments)*(1-(k/segments)*(second_activity_tot/first_activity_tot))*first_uncer_tot)^2+((1/first_activity_tot)*(second_activity_tot/first_activity_tot)^(k/segments)*second_uncer_tot)^2)
}
# Fill the missing uncertainties
pb210_data[i:(j - 1), 1] = filler_vec
pb210_data[i:(j - 1), 2] = filler_vec_uncer
}
}
# Move the index to j to continue checking for further missing values
i = j - 1
}
}
# Initialize a new dataframe to store the result
num_rows_zi <- nrow(pb210_data)
new_pb210_data <- data.frame(matrix(NA, nrow = num_rows_zi * 2, ncol = ncol(pb210_data)))
colnames(new_pb210_data) <- colnames(pb210_data)
# Fill the new dataframe with data and empty rows
for (i in 1:num_rows_zi) {
new_pb210_data[(i * 2 - 1), ] <- pb210_data[i, ]  # Fill the data row
# The even rows (i * 2) will remain NA by default
}
# Remove the last row if it is NA
if (all(is.na(new_pb210_data[nrow(new_pb210_data), ]))) {
new_pb210_data <- new_pb210_data[-nrow(new_pb210_data), ]
}
# Set the row names to run from 1 to the length of the data
rownames(new_pb210_data) <- 1:nrow(new_pb210_data)
# Assign the new dataframe back to pb210_data
pb210_data <- new_pb210_data
# Insert an NA row at the beginning if the first element is not NA
if (!is.na(pb210_data[1, 1])) {
if (ncol(pb210_data)==2){
empty_row <- data.frame(X = NA, X.1 = NA)  # Create a new data frame row
pb210_data <- rbind(empty_row, pb210_data)  # Bind the new row to the top
}else{
empty_row <- data.frame(X = NA, X.1 = NA, X.2=NA, X.3=NA)  # Create a new data frame row
pb210_data <- rbind(empty_row, pb210_data)  # Bind the new row to the top
}
}
# Reset row names to ensure they are sequential
rownames(pb210_data) <- 1:nrow(pb210_data)
pb210_data=as.matrix(pb210_data)
concentrations_table[1:(nrow(concentrations_table)),2]=pb210_data[,1]
pb210_data
# Define the path to your Excel file
new_column_names_pb210_data <- c("X", "X.1", "X.2", "X.3")
# Read the Excel file
file_path2=file.choose()
pb210_data <- read_excel(file_path2, col_names = TRUE, col_types = "numeric")
colnames(pb210_data) <- new_column_names_pb210_data
pb210_data=as.data.frame(pb210_data)
pb210_data
# Perform linear interpolation on the X values
pb210_data$interpolated_X.2 <- na.approx(pb210_data$X.2, na.rm = FALSE)
# Initialize a vector for propagated uncertainties
pb210_data$propagated_uncertainties_X.2 <- NA
pb210_data
# Loop through the interpolated X to calculate uncertainties
for (i in 1:nrow(pb210_data)) {
# Only calculate propagated uncertainty if the current uncertainty is NA
if (is.na(pb210_data$X.3[i])) {
# Find the nearest known X on both sides
left_index <- i - 1
while (left_index > 0 && (is.na(pb210_data$X.2[left_index]) || is.na(pb210_data$X.3[left_index]))) {
left_index <- left_index - 1
}
right_index <- i + 1
while (right_index < nrow(pb210_data) && (is.na(pb210_data$X.2[right_index]) || is.na(pb210_data$X.3[right_index]))) {
right_index <- right_index + 1
}
# Check if we found valid indices
if (left_index > 0 && right_index < nrow(pb210_data)) {
delta_y1 <- pb210_data$X.3[left_index]  # Use the correct column for uncertainties
x1 <- left_index
delta_y2 <- pb210_data$X.3[right_index]  # Use the correct column for uncertainties
x2 <- right_index
partial_der=(i-x1)/(x2-x1)
# Calculate propagated uncertainty
propagated_uncertainty <- sqrt(((1-partial_der)*delta_y1)^2 + (partial_der * delta_y2)^2)
pb210_data$propagated_uncertainties_X.2[i] <- propagated_uncertainty
}
}
}
pb210_data
pb210_data[,3]=pb210_data[,5]
pb210_data$X.3[is.na(pb210_data$X.3)] <- pb210_data$propagated_uncertainties[is.na(pb210_data$X.3)]
pb210_data=pb210_data[,1:4]
pb210_data
# Bn=A*(C/A)^(n/N) exponential interpolation of activities
for (i in 1:nrow(pb210_data)) {
# Check if the current uncertainty is missing
if (is.na(pb210_data[i, 2])) {
# Get the first activity from the previous row
first_activity_tot=pb210_data[(i-1),1]
first_uncer_tot=pb210_data[(i-1),2]
# Initialize a variable to track the end of the missing data
j = i
# Loop to fill in missing uncertainties
length_missing_data=1
while (j <= nrow(pb210_data) && is.na(pb210_data[j, 2])) {
j = j + 1
length_missing_data=length_missing_data+1
}
length_missing_data=length_missing_data-1
segments=length_missing_data+1
filler_vec=vector("numeric", length_missing_data)
filler_vec_uncer=vector("numeric", length_missing_data)
if (ncol(pb210_data)==4){
filler_vec2=vector("numeric", length_missing_data)
filler_vec_uncer2=vector("numeric", length_missing_data)
}
# Now j is the first non-missing uncertainty after the missing values
if (j <= nrow(pb210_data)) {
second_activity_tot = pb210_data[j, 1]
second_uncer_tot = pb210_data[j, 2]
# Check if both activities are numeric
if (is.numeric(first_activity_tot) && is.numeric(second_activity_tot)) {
# Calculate the filled activity
for (k in 1:length_missing_data){
filler_vec[k]=first_activity_tot*(second_activity_tot/first_activity_tot)^(k/segments)
filler_vec_uncer[k]=filler_vec[k]*sqrt(((second_activity_tot/first_activity_tot)^(k/segments)*(1-(k/segments)*(second_activity_tot/first_activity_tot))*first_uncer_tot)^2+((1/first_activity_tot)*(second_activity_tot/first_activity_tot)^(k/segments)*second_uncer_tot)^2)
}
# Fill the missing uncertainties
pb210_data[i:(j - 1), 1] = filler_vec
pb210_data[i:(j - 1), 2] = filler_vec_uncer
}
}
# Move the index to j to continue checking for further missing values
i = j - 1
}
}
pb210_data
exp((((4.1*10^6)/300^2)-3.7)/10^3)
((10^3+24.4)/(exp((((4.1*10^6)/300^2)-3.7)/10^3)))-10^3
setwd("c:/users/riley/documents/github")
source("Pb210Modeler")
source("Pb210Modeler.R")
setwd("c:/users/riley/documents/github/Pb210Modeler")
source("Pb210Modeler.R")
setwd("c:/users/riley/documents/github/Pb210Modeler")
source("Pb210Modeler.R")
setwd("c:/users/riley/documents/github/Pb210Modeler")
source("Pb210Modeler.R")
setwd("c:/users/riley/documents/github/Pb210Modeler")
source("Pb210Modeler.R")
